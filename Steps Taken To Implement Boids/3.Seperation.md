The first rule and this step of the program is to implement the seperation rule, in which:
- Each Boid must steer away from nearby voids, if there are multiple voids in the seperation range, the Boid needs to apply a weight inversly proportional to the distance between them.

Therefore, I assign a variable to handle the circular area around the Boid, in which it detects other Boids within it's seperation range in my Boid class from there I:
1. Assign a variable called SeperationRadius, instead of generalizing it as "Radius" for all three rules as I want the user to be able to customize each rule and the constaints that modify Boids, allowing for later, more detailed adjustments.
2. Now that I have an area around my Boid that can detect other Boids, I create my Seperation function, that has a variable called target as a PVector, which I will later assign the wanted velocity of the Boid to, i track the total number of Boids also in a variable called total, and do a generalized loop through every single Boid.
3. I track the distance between the current Boid and the Boid I am looping through using an inbuilt distance (dist), function.
4. Then I check that the Boid I am looping through, in this case other, is not the current Boid, and also that the distance is less then the radius, meaning the other Boid is within the radius of my current Boid.
5. I take the difference as a PVector of the two positions of the Boids, using Pvector.sub, tracking how far away the two Boids are.
6. I then take the difference between the two Boids and times them together to create a stronger repulsion when closer together and weaker when farther effect.
7. Then I add to the target that difference, and increase my total counter for the amount of Boids in that radius by 1.
8. Lastly I just do a return statement stating if total == 0 (as in no Boids are in that current radius of the other Boids, don't continue on with the next section of code)

Now that I have the amount of Boids within the Radius of my current Boid, and also a difference between the two Boids, I:
9. Turn the sum of all the differences into an average my doing a target.div(total), making the force of each Boid in the radius, effect the current Boid all equally at the same level, creating an average repusling direction. 
10. Then i set the magnitude (length) of a vector the the maxSpeed, whilst keeping the direction it's facing the same.
11. Now i set the force of acceleration which will be applied to the Boid as a Pvector called force, which subtracts the current velocity of the Boid, from the target velocity the Boid wants to get to, giving the amount of force that will need to be applied to the Boid to increase it's acceleration.
12. Then I apply a limit of maxForce as declared earlier onto the inital force itself before applying it to the Boid to avoid it gaining to much acceleration and flying away to fast.
13. Now I multiply the seperationCoefficient by the force to give the generalized force going to be applied to my Boids.
14. And now I add the force to the acceleration of my Boid.
15. Lastly in my update function for my Boids i call my newly created sepertion function, to apply the newly created rule to all my Boids.
16. Before we run anything, we need to declare the actual variable in the setup function, so when we run the application, the seperation variable is modifiable for later, currently we declare the seperation value, but we never give it a value, thus resulting in the Boids having a seperation value of 0 and not moving, so therefore, we assign the seperation to, in this case, 30 in the setup function.

Yay, we've done it, but now as you can see, the Boids run of screen, and don't comeback unless they get flung back towards our display off screen, to combat that we need to create a wrap around effect:
17. create our wrap function in the Boid class, and generally check the x and y position of the Boids, if:
    - the position of the Boid, pos.x < 0, then we know that the Boid has moved to the left side of the screen, and assign the x position of the Boid back to the right side, the width of the screen, we do the same but flipped if it moves too far right, and similarly same for the y coordinate, but instead using height as the comparator.
18. Now we call the wrap function in our update function that runs 60 times a second.

Alright now we can see all our Boids are staying on screen and wrapping around the other side instead of running away! Amazing! But if you look closely with a keen eye, you'll notice some exquisite behaviours about the Boids, when they become too close, and actually become on top of eachother, the amount of force blows up exponentially, especially if the Boids have a distance between them of 0, when we calculate the difference between them by doing diff.div(distanceBetweenBoids * distanceBetweenBoids), if we are at 0, we get a not a number error, as dividing by 0 is theoritically impossible, therefore in our if statement when calculating the distance between the Boids we simply add:
19. A check to ensure that the initial distance between the Boids is greater then 0

Thus catching all of the no actual number errors and ensuring insane forces are better calculated.

Finally Done! Atleast the first of the three applicable rules to Boids...




